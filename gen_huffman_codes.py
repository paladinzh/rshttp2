import re

TPL = '''\
// Generated by gen_huffman_codes.py. Do NEVER edit it directly.
use std::pin::Pin;
use std::ptr::null;
use std::marker::PhantomPinned;

#[derive(Debug)]
pub struct Item {
    lsb: u32,
    bits: usize,
}

pub struct HuffmanTree {
    nodes: Vec<TreeNode>,
    pub root: *const TreeNode,
    _pin: PhantomPinned,
}

#[derive(Debug, Clone)]
pub enum Char {
    Normal(u8),
    EoS,
}

#[derive(Debug)]
pub enum TreeNode {
    Leaf(Char),
    Inner((*const TreeNode, *const TreeNode)),
}

unsafe fn set_node_children(
    node: &mut TreeNode,
    left: *const TreeNode,
    right: *const TreeNode,
) -> () {
    match node {
        TreeNode::Leaf(_) => unreachable!(),
        TreeNode::Inner((ref mut l, ref mut r)) => {
            *l = left;
            *r = right;
        }
    }
}


impl HuffmanTree {
    pub fn new() -> Pin<Box<HuffmanTree>> {
        let res = HuffmanTree{
            nodes: vec!(),
            root: null(),
            _pin: PhantomPinned,
        };
        let mut boxed = Box::pin(res);
        unsafe {
            let mut_ref: Pin<&mut Self> = Pin::as_mut(&mut boxed);
            let mut_ref = Pin::get_unchecked_mut(mut_ref);

%(ADD_NODES)s

            let root = mut_ref.nodes.as_mut_ptr();
            mut_ref.root = root;

%(SET_CHILDREN)s
        }
        boxed
    }
}

pub const RAW_TABLE: [Item; 256] = [
%(ITEMS)s
];
'''

class Char:
    def new_normal(char):
        c = Char()
        c.normal_char = char
        return c

    def new_eos():
        c = Char()
        c.is_normal = False
        c.is_eos = True
        return c
    
    def __init__(self):
        self.is_normal = True
        self.normal_char = 0
        self.is_eos = False

    def __str__(self):
        if self.is_normal:
            return '[%s]' % hex(self.normal_char)
        else:
            return '[EoS]'

class Code:
    def __init__(self, bin_msb, hex_lsb, char):
        self.bin_msb = bin_msb.replace('|', '')
        self.hex_lsb = hex_lsb
        self.char = char

    def __str__(self):
        return '{"bin_msb": "%s", "hex_lsb": "%s", "char": "%s"}' % (self.bin_msb, self.hex_lsb, self.char)

def read_file():
    with open('huffman.txt') as fp:
        lines = [x.rstrip() for x in fp]
    lines = [x for x in lines if x]

    pat = re.compile('([01|]+)\s+([0-9a-f]+)\s+\[\s*(\d+)\]$')
    matches = [pat.search(x) for x in lines]
    codes = [Code(x.group(1), x.group(2), Char.new_normal(i)) for i, x in enumerate(matches)]
    for i, (c, m) in enumerate(zip(codes, matches)):
        assert len(c.bin_msb) == int(m.group(3)), i
    codes.append(Code('111111111111111111111111111111', '3fffffff', Char.new_eos()))
    return codes

class Node:
    def __init__(self, msb_chars):
        self.bfs_index = None
        if len(msb_chars) == 1:
            # leaf
            assert len(msb_chars[0][0]) == 0, msb_chars[0][1]
            self.is_leaf = True
            self.char = msb_chars[0][1]
        else:
            self.is_leaf = False
            self.left = Node([(x[0][1:], x[1]) for x in msb_chars if x[0][0] == '0'])
            self.right = Node([(x[0][1:], x[1]) for x in msb_chars if x[0][0] == '1'])

    def bfs(self):
        res = [self]
        todo = 0
        while todo < len(res):
            parent = res[todo]
            todo += 1
            if not parent.is_leaf:
                res.append(parent.left)
                res.append(parent.right)
        return res

def fix_bfs_index(bfs):
    for i, x in enumerate(bfs):
        x.bfs_index = i

def add_nodes_to_rust(bfs):
    res = []
    for x in bfs:
        if x.is_leaf:
            if x.char.is_normal:
                res.append('            mut_ref.nodes.push(TreeNode::Leaf(Char::Normal(%d)));' % x.char.normal_char)
            else:
                res.append('            mut_ref.nodes.push(TreeNode::Leaf(Char::EoS));')
        else:
            res.append('            mut_ref.nodes.push(TreeNode::Inner((null(), null())));')
    return '\n'.join(res)

def set_children_to_rust(bfs):
    res = []
    for x in bfs:
        if not x.is_leaf:
            parent_idx = x.bfs_index
            left_idx = x.left.bfs_index
            right_idx = x.right.bfs_index
            res.append('            set_node_children(&mut *(root.add(%d)), root.add(%d), root.add(%d));' % (parent_idx, left_idx, right_idx))
    return '\n'.join(res)

if __name__ == '__main__':
    codes = read_file()

    raw_table = '\n'.join('    Item{lsb: 0x%s, bits: %s},' % (x.hex_lsb, len(x.bin_msb)) for x in codes[:-1])

    root = Node([(x.bin_msb, x.char) for x in codes])
    bfs = root.bfs()
    fix_bfs_index(bfs)

    add_nodes = add_nodes_to_rust(bfs)
    set_children = set_children_to_rust(bfs)

    print(TPL % {'ITEMS': raw_table, 'ADD_NODES': add_nodes, 'SET_CHILDREN': set_children})
